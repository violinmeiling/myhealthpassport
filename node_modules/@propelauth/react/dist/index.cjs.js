'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var React = require('react');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var React__default = /*#__PURE__*/_interopDefaultLegacy(React);

/*! js-cookie v3.0.5 | MIT */
/* eslint-disable no-var */
function assign (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];
    for (var key in source) {
      target[key] = source[key];
    }
  }
  return target
}
/* eslint-enable no-var */

/* eslint-disable no-var */
var defaultConverter = {
  read: function (value) {
    if (value[0] === '"') {
      value = value.slice(1, -1);
    }
    return value.replace(/(%[\dA-F]{2})+/gi, decodeURIComponent)
  },
  write: function (value) {
    return encodeURIComponent(value).replace(
      /%(2[346BF]|3[AC-F]|40|5[BDE]|60|7[BCD])/g,
      decodeURIComponent
    )
  }
};
/* eslint-enable no-var */

/* eslint-disable no-var */

function init (converter, defaultAttributes) {
  function set (name, value, attributes) {
    if (typeof document === 'undefined') {
      return
    }

    attributes = assign({}, defaultAttributes, attributes);

    if (typeof attributes.expires === 'number') {
      attributes.expires = new Date(Date.now() + attributes.expires * 864e5);
    }
    if (attributes.expires) {
      attributes.expires = attributes.expires.toUTCString();
    }

    name = encodeURIComponent(name)
      .replace(/%(2[346B]|5E|60|7C)/g, decodeURIComponent)
      .replace(/[()]/g, escape);

    var stringifiedAttributes = '';
    for (var attributeName in attributes) {
      if (!attributes[attributeName]) {
        continue
      }

      stringifiedAttributes += '; ' + attributeName;

      if (attributes[attributeName] === true) {
        continue
      }

      // Considers RFC 6265 section 5.2:
      // ...
      // 3.  If the remaining unparsed-attributes contains a %x3B (";")
      //     character:
      // Consume the characters of the unparsed-attributes up to,
      // not including, the first %x3B (";") character.
      // ...
      stringifiedAttributes += '=' + attributes[attributeName].split(';')[0];
    }

    return (document.cookie =
      name + '=' + converter.write(value, name) + stringifiedAttributes)
  }

  function get (name) {
    if (typeof document === 'undefined' || (arguments.length && !name)) {
      return
    }

    // To prevent the for loop in the first place assign an empty array
    // in case there are no cookies at all.
    var cookies = document.cookie ? document.cookie.split('; ') : [];
    var jar = {};
    for (var i = 0; i < cookies.length; i++) {
      var parts = cookies[i].split('=');
      var value = parts.slice(1).join('=');

      try {
        var found = decodeURIComponent(parts[0]);
        jar[found] = converter.read(value, found);

        if (name === found) {
          break
        }
      } catch (e) {}
    }

    return name ? jar[name] : jar
  }

  return Object.create(
    {
      set,
      get,
      remove: function (name, attributes) {
        set(
          name,
          '',
          assign({}, attributes, {
            expires: -1
          })
        );
      },
      withAttributes: function (attributes) {
        return init(this.converter, assign({}, this.attributes, attributes))
      },
      withConverter: function (converter) {
        return init(assign({}, this.converter, converter), this.attributes)
      }
    },
    {
      attributes: { value: Object.freeze(defaultAttributes) },
      converter: { value: Object.freeze(converter) }
    }
  )
}

init(defaultConverter, { path: '/' });

let OrgRoleStructure = /*#__PURE__*/function (OrgRoleStructure) {
  OrgRoleStructure["SingleRole"] = "single_role_in_hierarchy";
  OrgRoleStructure["MultiRole"] = "multi_role";
  return OrgRoleStructure;
}({});

function getAccessHelper$1(orgIdToOrgMemberInfo) {
  function isRole(orgId, role) {
    const orgMemberInfo = orgIdToOrgMemberInfo[orgId];
    if (orgMemberInfo === undefined) {
      return false;
    }
    if (orgMemberInfo.orgRoleStructure === OrgRoleStructure.MultiRole) {
      return orgMemberInfo.userAssignedRole === role || orgMemberInfo.userAssignedAdditionalRoles.includes(role);
    } else {
      return orgMemberInfo.userAssignedRole === role;
    }
  }
  function isAtLeastRole(orgId, role) {
    const orgMemberInfo = orgIdToOrgMemberInfo[orgId];
    if (orgMemberInfo === undefined) {
      return false;
    }
    if (orgMemberInfo.orgRoleStructure === OrgRoleStructure.MultiRole) {
      return orgMemberInfo.userAssignedRole === role || orgMemberInfo.userAssignedAdditionalRoles.includes(role);
    } else {
      return orgMemberInfo.userInheritedRolesPlusCurrentRole.includes(role);
    }
  }
  function hasPermission(orgId, permission) {
    const orgMemberInfo = orgIdToOrgMemberInfo[orgId];
    if (orgMemberInfo === undefined) {
      return false;
    }
    return orgMemberInfo.userPermissions.includes(permission);
  }
  function hasAllPermissions(orgId, permissions) {
    const orgMemberInfo = orgIdToOrgMemberInfo[orgId];
    if (orgMemberInfo === undefined) {
      return false;
    }
    return permissions.every(permission => orgMemberInfo.userPermissions.includes(permission));
  }
  function getAccessHelperWithOrgId(orgId) {
    return {
      isRole(role) {
        return isRole(orgId, role);
      },
      isAtLeastRole(role) {
        return isAtLeastRole(orgId, role);
      },
      hasPermission(permission) {
        return hasPermission(orgId, permission);
      },
      hasAllPermissions(permissions) {
        return hasAllPermissions(orgId, permissions);
      }
    };
  }
  return {
    isRole,
    isAtLeastRole,
    hasPermission,
    hasAllPermissions,
    getAccessHelperWithOrgId
  };
}

function getOrgHelper$1(orgIdToOrgMemberInfo) {
  return {
    getOrg(orgId) {
      if (orgIdToOrgMemberInfo.hasOwnProperty(orgId)) {
        return orgIdToOrgMemberInfo[orgId];
      } else {
        return undefined;
      }
    },
    getOrgIds() {
      return Object.keys(orgIdToOrgMemberInfo);
    },
    getOrgs() {
      return Object.values(orgIdToOrgMemberInfo);
    },
    getOrgByName(orgName) {
      for (const orgMemberInfo of Object.values(orgIdToOrgMemberInfo)) {
        if (orgMemberInfo.orgName === orgName || orgMemberInfo.urlSafeOrgName === orgName) {
          return orgMemberInfo;
        }
      }
      return undefined;
    }
  };
}

class UserClass {
  // Metadata about the user

  // If you used our migration APIs to migrate this user from a different system,
  // this is their original ID from that system.

  constructor(userFields, orgIdToUserOrgInfo) {
    this.userId = userFields.userId;
    this.orgIdToUserOrgInfo = orgIdToUserOrgInfo;
    this.email = userFields.email;
    this.firstName = userFields.firstName;
    this.lastName = userFields.lastName;
    this.username = userFields.username;
    this.createdAt = userFields.createdAt;
    this.pictureUrl = userFields.pictureUrl;
    this.hasPassword = userFields.hasPassword;
    this.hasMfaEnabled = userFields.hasMfaEnabled;
    this.canCreateOrgs = userFields.canCreateOrgs;
    this.legacyUserId = userFields.legacyUserId;
    this.impersonatorUserId = userFields.impersonatorUserId;
    this.properties = userFields.properties;
  }
  getOrg(orgId) {
    if (!this.orgIdToUserOrgInfo) {
      return undefined;
    }
    return this.orgIdToUserOrgInfo[orgId];
  }
  getOrgByName(orgName) {
    if (!this.orgIdToUserOrgInfo) {
      return undefined;
    }
    const urlSafeOrgName = orgName.toLowerCase().replace(/ /g, "-");
    for (const orgId in this.orgIdToUserOrgInfo) {
      const orgMemberInfo = this.orgIdToUserOrgInfo[orgId];
      if ((orgMemberInfo === null || orgMemberInfo === void 0 ? void 0 : orgMemberInfo.urlSafeOrgName) === urlSafeOrgName) {
        return orgMemberInfo;
      }
    }
    return undefined;
  }
  getUserProperty(key) {
    if (!this.properties) {
      return undefined;
    }
    return this.properties[key];
  }
  getOrgs() {
    if (!this.orgIdToUserOrgInfo) {
      return [];
    }
    return Object.values(this.orgIdToUserOrgInfo);
  }
  isImpersonating() {
    return !!this.impersonatorUserId;
  }
  isRole(orgId, role) {
    const orgMemberInfo = this.getOrg(orgId);
    if (!orgMemberInfo) {
      return false;
    }
    return orgMemberInfo.isRole(role);
  }
  isAtLeastRole(orgId, role) {
    const orgMemberInfo = this.getOrg(orgId);
    if (!orgMemberInfo) {
      return false;
    }
    return orgMemberInfo.isAtLeastRole(role);
  }
  hasPermission(orgId, permission) {
    const orgMemberInfo = this.getOrg(orgId);
    if (!orgMemberInfo) {
      return false;
    }
    return orgMemberInfo.hasPermission(permission);
  }
  hasAllPermissions(orgId, permissions) {
    const orgMemberInfo = this.getOrg(orgId);
    if (!orgMemberInfo) {
      return false;
    }
    return orgMemberInfo.hasAllPermissions(permissions);
  }
  static fromJSON(json) {
    const obj = JSON.parse(json);
    const orgIdToUserOrgInfo = {};
    for (const orgId in obj.orgIdToUserOrgInfo) {
      orgIdToUserOrgInfo[orgId] = OrgMemberInfoClass.fromJSON(JSON.stringify(obj.orgIdToUserOrgInfo[orgId]));
    }
    try {
      return new UserClass({
        userId: obj.userId,
        email: obj.email,
        createdAt: obj.createdAt,
        firstName: obj.firstName,
        lastName: obj.lastName,
        username: obj.username,
        legacyUserId: obj.legacyUserId,
        impersonatorUserId: obj.impersonatorUserId,
        properties: obj.properties,
        pictureUrl: obj.pictureUrl,
        hasPassword: obj.hasPassword,
        hasMfaEnabled: obj.hasMfaEnabled,
        canCreateOrgs: obj.canCreateOrgs
      }, orgIdToUserOrgInfo);
    } catch (e) {
      console.error("Unable to parse User. Make sure the JSON string is a stringified `UserClass` type.", e);
      throw e;
    }
  }
}
class OrgMemberInfoClass {
  constructor(orgId, orgName, orgMetadata, urlSafeOrgName, userAssignedRole, userInheritedRolesPlusCurrentRole, userPermissions, orgRoleStructure, userAssignedAdditionalRoles) {
    this.orgId = orgId;
    this.orgName = orgName;
    this.orgMetadata = orgMetadata;
    this.urlSafeOrgName = urlSafeOrgName;
    this.orgRoleStructure = orgRoleStructure !== null && orgRoleStructure !== void 0 ? orgRoleStructure : OrgRoleStructure.SingleRole;
    this.userAssignedRole = userAssignedRole;
    this.userInheritedRolesPlusCurrentRole = userInheritedRolesPlusCurrentRole;
    this.userPermissions = userPermissions;
    this.userAssignedAdditionalRoles = userAssignedAdditionalRoles !== null && userAssignedAdditionalRoles !== void 0 ? userAssignedAdditionalRoles : [];
  }

  // validation methods
  isRole(role) {
    if (this.orgRoleStructure === OrgRoleStructure.MultiRole) {
      return this.userAssignedRole === role || this.userAssignedAdditionalRoles.includes(role);
    } else {
      return this.userAssignedRole === role;
    }
  }
  isAtLeastRole(role) {
    if (this.orgRoleStructure === OrgRoleStructure.MultiRole) {
      return this.userAssignedRole === role || this.userAssignedAdditionalRoles.includes(role);
    } else {
      return this.userInheritedRolesPlusCurrentRole.includes(role);
    }
  }
  hasPermission(permission) {
    return this.userPermissions.includes(permission);
  }
  hasAllPermissions(permissions) {
    return permissions.every(permission => this.hasPermission(permission));
  }
  static fromJSON(json) {
    const obj = JSON.parse(json);
    try {
      return new OrgMemberInfoClass(obj.orgId, obj.orgName, obj.orgMetadata, obj.urlSafeOrgName, obj.userAssignedRole, obj.userInheritedRolesPlusCurrentRole, obj.userPermissions, obj.orgRoleStructure, obj.userAssignedAdditionalRoles);
    } catch (e) {
      console.error("Unable to parse UserOrgInfo. Make sure the JSON string is a stringified `UserOrgInfo` type.", e);
      throw e;
    }
  }
}
function convertOrgIdToOrgMemberInfo(orgIdToOrgMemberInfo) {
  if (orgIdToOrgMemberInfo === undefined) {
    return undefined;
  }
  const orgIdToUserOrgInfo = {};
  for (const orgMemberInfo of Object.values(orgIdToOrgMemberInfo)) {
    orgIdToUserOrgInfo[orgMemberInfo.orgId] = new OrgMemberInfoClass(orgMemberInfo.orgId, orgMemberInfo.orgName, orgMemberInfo.orgMetadata, orgMemberInfo.urlSafeOrgName, orgMemberInfo.userAssignedRole, orgMemberInfo.userInheritedRolesPlusCurrentRole, orgMemberInfo.userPermissions, orgMemberInfo.orgRoleStructure, orgMemberInfo.userAssignedAdditionalRoles);
  }
  return orgIdToUserOrgInfo;
}

function fetchAuthenticationInfo(authUrl, activeOrgId) {
  const queryParams = new URLSearchParams();
  if (activeOrgId) {
    queryParams.append("active_org_id", activeOrgId);
  }
  let path = `${authUrl}/api/v1/refresh_token`;
  if (queryParams.toString()) {
    path += `?${queryParams.toString()}`;
  }
  return fetch(path, {
    method: "GET",
    credentials: "include",
    headers: {
      "Content-Type": "application/json"
    }
  }).then(res => {
    if (res.status === 401) {
      return null;
    } else if (res.status === 0) {
      logCorsError();
      return Promise.reject({
        status: 503,
        message: "Unable to process authentication response"
      });
    } else if (!res.ok) {
      return Promise.reject({
        status: res.status,
        message: res.statusText
      });
    } else {
      return parseResponse(res);
    }
  });
}
function logout(authUrl) {
  return fetch(`${authUrl}/api/v1/logout`, {
    method: "POST",
    credentials: "include",
    headers: {
      "Content-Type": "application/json"
    }
  }).then(res => {
    if (res.status === 0) {
      logCorsError();
      return Promise.reject({
        status: 503,
        message: "Unable to process authentication response"
      });
    } else if (!res.ok) {
      console.error("Logout error", res.status, res.statusText);
      return Promise.reject({
        status: res.status,
        message: res.statusText
      });
    } else {
      return res.json();
    }
  });
}
function parseResponse(res) {
  return res.text().then(httpResponse => {
    try {
      const authInfoWithoutUserClass = parseJsonConvertingSnakeToCamel(httpResponse);
      return withExtraArgs(authInfoWithoutUserClass);
    } catch (e) {
      console.error("Unable to process authentication response", e);
      return Promise.reject({
        status: 500,
        message: "Unable to process authentication response"
      });
    }
  }, e => {
    console.error("Unable to process authentication response", e);
    return Promise.reject({
      status: 500,
      message: "Unable to process authentication response"
    });
  });
}

// The API responds with snake_case, but TypeScript convention is camelCase.
// When parsing JSON, we pass in reviver function to convert from snake_case to camelCase.
function parseJsonConvertingSnakeToCamel(str) {
  return JSON.parse(str, function (key, value) {
    if (key === "org_id") {
      this.orgId = value;
    } else if (key === "org_name") {
      this.orgName = value;
    } else if (key === "org_metadata") {
      this.orgMetadata = value;
    } else if (key === "url_safe_org_name") {
      this.urlSafeOrgName = value;
    } else if (key === "user_role") {
      this.userAssignedRole = value;
    } else if (key === "inherited_user_roles_plus_current_role") {
      this.userInheritedRolesPlusCurrentRole = value;
    } else if (key === "user_permissions") {
      this.userPermissions = value;
    } else if (key === "access_token") {
      this.accessToken = value;
    } else if (key === "expires_at_seconds") {
      this.expiresAtSeconds = value;
    } else if (key === "org_id_to_org_member_info") {
      this.orgIdToOrgMemberInfo = value;
    } else if (key === "user_id") {
      this.userId = value;
    } else if (key === "email_confirmed") {
      this.emailConfirmed = value;
    } else if (key === "first_name") {
      this.firstName = value;
    } else if (key === "last_name") {
      this.lastName = value;
    } else if (key === "picture_url") {
      this.pictureUrl = value;
    } else if (key === "mfa_enabled") {
      this.mfaEnabled = value;
    } else if (key === "has_password") {
      this.hasPassword = value;
    } else if (key === "can_create_orgs") {
      this.canCreateOrgs = value;
    } else if (key === "created_at") {
      this.createdAt = value;
    } else if (key === "last_active_at") {
      this.lastActiveAt = value;
    } else if (key === "legacy_user_id") {
      this.legacyUserId = value;
    } else if (key === "impersonator_user") {
      this.impersonatorUserId = value;
    } else if (key === "org_role_structure") {
      this.orgRoleStructure = value;
    } else if (key === "additional_roles") {
      this.userAssignedAdditionalRoles = value;
    } else {
      return value;
    }
  });
}
function withExtraArgs(authInfoWithoutExtraArgs) {
  if (authInfoWithoutExtraArgs.orgIdToOrgMemberInfo) {
    authInfoWithoutExtraArgs.orgHelper = getOrgHelper$1(authInfoWithoutExtraArgs.orgIdToOrgMemberInfo);
    authInfoWithoutExtraArgs.accessHelper = getAccessHelper$1(authInfoWithoutExtraArgs.orgIdToOrgMemberInfo);
  }
  authInfoWithoutExtraArgs.userClass = new UserClass({
    userId: authInfoWithoutExtraArgs.user.userId,
    email: authInfoWithoutExtraArgs.user.email,
    createdAt: authInfoWithoutExtraArgs.user.createdAt,
    firstName: authInfoWithoutExtraArgs.user.firstName,
    lastName: authInfoWithoutExtraArgs.user.lastName,
    username: authInfoWithoutExtraArgs.user.username,
    properties: authInfoWithoutExtraArgs.user.properties,
    pictureUrl: authInfoWithoutExtraArgs.user.pictureUrl,
    hasPassword: authInfoWithoutExtraArgs.user.hasPassword,
    hasMfaEnabled: authInfoWithoutExtraArgs.user.mfaEnabled,
    canCreateOrgs: authInfoWithoutExtraArgs.user.canCreateOrgs,
    legacyUserId: authInfoWithoutExtraArgs.user.legacyUserId,
    impersonatorUserId: authInfoWithoutExtraArgs.impersonatorUserId
  }, convertOrgIdToOrgMemberInfo(authInfoWithoutExtraArgs.orgIdToOrgMemberInfo));
  return Promise.resolve(authInfoWithoutExtraArgs);
}
function logCorsError() {
  console.error("Request to PropelAuth failed due to a CORS error. There are a few likely causes: \n" + " 1. In the Frontend Integration section of your dashboard, make sure your requests are coming either the specified Application URL or localhost with a matching port.\n" + " 2. Make sure your server is hosted on HTTPS in production.");
}

const DEFAULT_RETRIES = 3;
const runWithRetriesOnAnyError = async fn => {
  return runWithRetriesInner(fn, DEFAULT_RETRIES);
};
const runWithRetriesInner = async (fn, numRetriesLeft) => {
  try {
    return await fn();
  } catch (e) {
    if (numRetriesLeft <= 0) {
      throw e;
    }
    await delay(numRetriesLeftToDelay(numRetriesLeft));
    return runWithRetriesInner(fn, numRetriesLeft - 1);
  }
};
const delay = ms => new Promise(resolve => setTimeout(resolve, ms));
const numRetriesLeftToDelay = numRetriesLeft => {
  // We could be fancy, but we only retry 3 times so...
  if (numRetriesLeft >= 3) {
    return 100;
  } else if (numRetriesLeft === 2) {
    return 200;
  } else {
    return 300;
  }
};

function currentTimeSeconds() {
  return Date.now() / 1000;
}
function hasLocalStorage() {
  return typeof localStorage !== "undefined";
}
function hasWindow() {
  return typeof window !== "undefined";
}
function getLocalStorageNumber(key) {
  if (!hasLocalStorage()) {
    return null;
  }
  const value = localStorage.getItem(key);
  if (!value) {
    return null;
  }
  const num = parseInt(value, 10);
  if (Number.isNaN(num)) {
    return null;
  }
  return num;
}

const LOGGED_IN_AT_KEY = "__PROPEL_AUTH_LOGGED_IN_AT";
const LOGGED_OUT_AT_KEY = "__PROPEL_AUTH_LOGGED_OUT_AT";
const AUTH_TOKEN_REFRESH_BEFORE_EXPIRATION_SECONDS = 10 * 60;
const DEBOUNCE_DURATION_FOR_REFOCUS_SECONDS = 60;
const ACTIVE_ORG_ACCESS_TOKEN_REFRESH_EXPIRATION_SECONDS = 60 * 5;
const encodeBase64 = str => {
  const encode = window ? window.btoa : btoa;
  return encode(str);
};
function validateAndCleanupOptions(authOptions) {
  try {
    // This helps make sure we have a consistent URL ignoring things like trailing slashes
    const authUrl = new URL(authOptions.authUrl);
    authOptions.authUrl = authUrl.origin;
  } catch (e) {
    console.error("Invalid authUrl", e);
    throw new Error("Unable to initialize auth client");
  }
  if (authOptions.enableBackgroundTokenRefresh === undefined) {
    authOptions.enableBackgroundTokenRefresh = true;
  }
}
function createClient(authOptions) {
  validateAndCleanupOptions(authOptions);

  // Internal state
  const clientState = {
    initialLoadFinished: false,
    authenticationInfo: null,
    observers: [],
    accessTokenObservers: [],
    lastLoggedInAtMessage: getLocalStorageNumber(LOGGED_IN_AT_KEY),
    lastLoggedOutAtMessage: getLocalStorageNumber(LOGGED_OUT_AT_KEY),
    authUrl: authOptions.authUrl,
    refreshInterval: null,
    lastRefresh: null,
    accessTokenActiveOrgMap: {}
  };

  // Helper functions
  function notifyObservers(isLoggedIn) {
    for (let i = 0; i < clientState.observers.length; i++) {
      const observer = clientState.observers[i];
      if (observer) {
        observer(isLoggedIn);
      }
    }
  }
  function notifyObserversOfAccessTokenChange(accessToken) {
    for (let i = 0; i < clientState.accessTokenObservers.length; i++) {
      const observer = clientState.accessTokenObservers[i];
      if (observer) {
        observer(accessToken);
      }
    }
  }
  function userJustLoggedOut(accessToken, previousAccessToken) {
    // Edge case: the first time we go to the page, if we can't load the
    //   auth token we should treat it as a logout event
    return !accessToken && (previousAccessToken || !clientState.initialLoadFinished);
  }
  function userJustLoggedIn(accessToken, previousAccessToken) {
    return !previousAccessToken && accessToken;
  }
  function updateLastLoggedOutAt() {
    const loggedOutAt = currentTimeSeconds();
    clientState.lastLoggedOutAtMessage = loggedOutAt;
    if (hasLocalStorage()) {
      localStorage.setItem(LOGGED_OUT_AT_KEY, String(loggedOutAt));
    }
  }
  function updateLastLoggedInAt() {
    const loggedInAt = currentTimeSeconds();
    clientState.lastLoggedInAtMessage = loggedInAt;
    if (hasLocalStorage()) {
      localStorage.setItem(LOGGED_IN_AT_KEY, String(loggedInAt));
    }
  }

  /**
   * Invalidates all org's access tokens.
   */
  function resetAccessTokenActiveOrgMap() {
    clientState.accessTokenActiveOrgMap = {};
  }
  function setAuthenticationInfoAndUpdateDownstream(authenticationInfo) {
    var _clientState$authenti;
    const previousAccessToken = (_clientState$authenti = clientState.authenticationInfo) === null || _clientState$authenti === void 0 ? void 0 : _clientState$authenti.accessToken;
    clientState.authenticationInfo = authenticationInfo;
    const accessToken = authenticationInfo === null || authenticationInfo === void 0 ? void 0 : authenticationInfo.accessToken;
    if (userJustLoggedOut(accessToken, previousAccessToken)) {
      notifyObservers(false);
      updateLastLoggedOutAt();
    } else if (userJustLoggedIn(accessToken, previousAccessToken)) {
      notifyObservers(true);
      updateLastLoggedInAt();
    }
    if (previousAccessToken !== accessToken) {
      notifyObserversOfAccessTokenChange(accessToken);
    }
    resetAccessTokenActiveOrgMap();
    clientState.lastRefresh = currentTimeSeconds();
    clientState.initialLoadFinished = true;
  }
  async function forceRefreshToken(returnCached) {
    try {
      // Happy case, we fetch auth info and save it
      const authenticationInfo = await runWithRetriesOnAnyError(() => fetchAuthenticationInfo(clientState.authUrl));
      setAuthenticationInfoAndUpdateDownstream(authenticationInfo);
      return authenticationInfo;
    } catch (e) {
      // If there was an error, we sometimes still want to return the value we have cached
      //   (e.g. if we were prefetching), so in those cases we swallow the exception
      if (returnCached) {
        return clientState.authenticationInfo;
      } else {
        setAuthenticationInfoAndUpdateDownstream(null);
        throw e;
      }
    }
  }
  const getSignupPageUrl = options => {
    let qs = new URLSearchParams();
    let url = `${clientState.authUrl}/signup`;
    if (options) {
      const {
        postSignupRedirectUrl,
        userSignupQueryParameters
      } = options;
      if (postSignupRedirectUrl) {
        qs.set("rt", encodeBase64(postSignupRedirectUrl));
      }
      if (userSignupQueryParameters) {
        Object.entries(userSignupQueryParameters).forEach(([key, value]) => {
          qs.set(key, value);
        });
      }
    }
    if (qs.toString()) {
      url += `?${qs.toString()}`;
    }
    return url;
  };
  const getLoginPageUrl = options => {
    let qs = new URLSearchParams();
    let url = `${clientState.authUrl}/login`;
    if (options) {
      const {
        postLoginRedirectUrl,
        userSignupQueryParameters
      } = options;
      if (postLoginRedirectUrl) {
        qs.set("rt", encodeBase64(postLoginRedirectUrl));
      }
      if (userSignupQueryParameters) {
        Object.entries(userSignupQueryParameters).forEach(([key, value]) => {
          qs.set(key, value);
        });
      }
    }
    if (qs.toString()) {
      url += `?${qs.toString()}`;
    }
    return url;
  };
  const getAccountPageUrl = options => {
    let qs = new URLSearchParams();
    let url = `${clientState.authUrl}/account`;
    if (options) {
      const {
        redirectBackToUrl
      } = options;
      if (redirectBackToUrl) {
        qs.set("rt", encodeBase64(redirectBackToUrl));
      }
    }
    if (qs.toString()) {
      url += `?${qs.toString()}`;
    }
    return url;
  };
  const getOrgPageUrl = (orgId, options) => {
    let qs = new URLSearchParams();
    let url = `${clientState.authUrl}/org`;
    if (orgId) {
      qs.set("id", orgId);
    }
    if (options) {
      if (options.redirectBackToUrl) {
        qs.set("rt", encodeBase64(options.redirectBackToUrl));
      }
    }
    if (qs.toString()) {
      url += `?${qs.toString()}`;
    }
    return url;
  };
  const getCreateOrgPageUrl = options => {
    let qs = new URLSearchParams();
    let url = `${clientState.authUrl}/create_org`;
    if (options) {
      const {
        redirectBackToUrl
      } = options;
      if (redirectBackToUrl) {
        qs.set("rt", encodeBase64(redirectBackToUrl));
      }
    }
    if (qs.toString()) {
      url += `?${qs.toString()}`;
    }
    return url;
  };
  const getSetupSAMLPageUrl = (orgId, options) => {
    let qs = new URLSearchParams();
    if (options) {
      if (options.redirectBackToUrl) {
        qs.set("rt", encodeBase64(options.redirectBackToUrl));
      }
    }
    qs.set("id", orgId);
    return `${clientState.authUrl}/saml?${qs.toString()}`;
  };
  const client = {
    addLoggedInChangeObserver(loggedInChangeObserver) {
      const hasObserver = clientState.observers.includes(loggedInChangeObserver);
      if (hasObserver) {
        console.error("Observer has been attached already.");
      } else if (!loggedInChangeObserver) {
        console.error("Cannot add a null observer");
      } else {
        clientState.observers.push(loggedInChangeObserver);
      }
    },
    removeLoggedInChangeObserver(loggedInChangeObserver) {
      const observerIndex = clientState.observers.indexOf(loggedInChangeObserver);
      if (observerIndex === -1) {
        console.error("Cannot find observer to remove");
      } else {
        clientState.observers.splice(observerIndex, 1);
      }
    },
    addAccessTokenChangeObserver(observer) {
      const hasObserver = clientState.accessTokenObservers.includes(observer);
      if (hasObserver) {
        console.error("Observer has been attached already.");
      } else if (!observer) {
        console.error("Cannot add a null observer");
      } else {
        clientState.accessTokenObservers.push(observer);
      }
    },
    removeAccessTokenChangeObserver(observer) {
      const observerIndex = clientState.accessTokenObservers.indexOf(observer);
      if (observerIndex === -1) {
        console.error("Cannot find observer to remove");
      } else {
        clientState.accessTokenObservers.splice(observerIndex, 1);
      }
    },
    async getAuthenticationInfoOrNull(forceRefresh) {
      const currentTimeSecs = currentTimeSeconds();
      if (forceRefresh) {
        return await forceRefreshToken(false);
      } else if (!clientState.authenticationInfo) {
        return await forceRefreshToken(false);
      } else if (currentTimeSecs + AUTH_TOKEN_REFRESH_BEFORE_EXPIRATION_SECONDS > clientState.authenticationInfo.expiresAtSeconds) {
        // Small edge case: If we were being proactive
        //   and the auth information hasn't expired yet, swallow any exceptions
        const returnCached = currentTimeSecs < clientState.authenticationInfo.expiresAtSeconds;
        return await forceRefreshToken(returnCached);
      } else {
        return clientState.authenticationInfo;
      }
    },
    async getAccessTokenForOrg(orgId) {
      // First, check if there is a valid access token for the org ID in the
      // valid time frame.
      const currentTimeSecs = currentTimeSeconds();
      const activeOrgAccessToken = clientState.accessTokenActiveOrgMap[orgId];
      if (!!activeOrgAccessToken) {
        if (currentTimeSecs < activeOrgAccessToken.fetchedAt + ACTIVE_ORG_ACCESS_TOKEN_REFRESH_EXPIRATION_SECONDS) {
          return {
            accessToken: activeOrgAccessToken.accessToken,
            error: undefined
          };
        }
      }
      // Fetch the access token for the org ID and update.
      try {
        const authenticationInfo = await runWithRetriesOnAnyError(() => fetchAuthenticationInfo(clientState.authUrl, orgId));
        if (!authenticationInfo) {
          // Only null if 401 unauthorized.
          return {
            error: "user_not_in_org",
            accessToken: null
          };
        }
        const {
          accessToken
        } = authenticationInfo;
        clientState.accessTokenActiveOrgMap[orgId] = {
          accessToken,
          fetchedAt: currentTimeSecs
        };
        return {
          accessToken,
          error: undefined
        };
      } catch (e) {
        return {
          error: "unexpected_error",
          accessToken: null
        };
      }
    },
    getSignupPageUrl(options) {
      return getSignupPageUrl(options);
    },
    getLoginPageUrl(options) {
      return getLoginPageUrl(options);
    },
    getAccountPageUrl(options) {
      return getAccountPageUrl(options);
    },
    getOrgPageUrl(orgId, options) {
      return getOrgPageUrl(orgId, options);
    },
    getCreateOrgPageUrl(options) {
      return getCreateOrgPageUrl(options);
    },
    getSetupSAMLPageUrl(orgId, options) {
      return getSetupSAMLPageUrl(orgId, options);
    },
    redirectToSignupPage(options) {
      window.location.href = getSignupPageUrl(options);
    },
    redirectToLoginPage(options) {
      window.location.href = getLoginPageUrl(options);
    },
    redirectToAccountPage(options) {
      window.location.href = getAccountPageUrl(options);
    },
    redirectToOrgPage(orgId, options) {
      window.location.href = getOrgPageUrl(orgId, options);
    },
    redirectToCreateOrgPage(options) {
      window.location.href = getCreateOrgPageUrl(options);
    },
    redirectToSetupSAMLPage(orgId, options) {
      window.location.href = getSetupSAMLPageUrl(orgId, options);
    },
    async logout(redirectAfterLogout) {
      const logoutResponse = await logout(clientState.authUrl);
      setAuthenticationInfoAndUpdateDownstream(null);
      if (redirectAfterLogout) {
        window.location.href = logoutResponse.redirect_to;
      }
    },
    destroy() {
      clientState.observers = [];
      clientState.accessTokenObservers = [];
      window.removeEventListener("storage", onStorageChange);
      if (clientState.refreshInterval) {
        clearInterval(clientState.refreshInterval);
      }
    }
  };
  const onStorageChange = async function () {
    // If localStorage isn't available, nothing to do here.
    // This usually happens in frameworks that have some SSR components
    if (!hasLocalStorage()) {
      return;
    }
    const loggedOutAt = getLocalStorageNumber(LOGGED_OUT_AT_KEY);
    const loggedInAt = getLocalStorageNumber(LOGGED_IN_AT_KEY);

    // If we've detected a logout event after the last one our client is aware of, trigger a refresh
    if (loggedOutAt && (!clientState.lastLoggedOutAtMessage || loggedOutAt > clientState.lastLoggedOutAtMessage)) {
      clientState.lastLoggedOutAtMessage = loggedOutAt;
      if (clientState.authenticationInfo) {
        await forceRefreshToken(true);
      }
    }

    // If we've detected a login event after the last one our client is aware of, trigger a refresh
    if (loggedInAt && (!clientState.lastLoggedInAtMessage || loggedInAt > clientState.lastLoggedInAtMessage)) {
      clientState.lastLoggedInAtMessage = loggedInAt;
      if (!clientState.authenticationInfo) {
        await forceRefreshToken(true);
      }
    }
  };

  // If we were offline or on a different tab, when we return, refetch auth info
  // Some browsers trigger focus more often than we'd like, so we'll debounce a little here as well
  const onOnlineOrFocus = async function () {
    if (clientState.lastRefresh && currentTimeSeconds() > clientState.lastRefresh + DEBOUNCE_DURATION_FOR_REFOCUS_SECONDS) {
      await forceRefreshToken(true);
    } else {
      await client.getAuthenticationInfoOrNull();
    }
  };
  if (hasWindow()) {
    window.addEventListener("storage", onStorageChange);
    window.addEventListener("online", onOnlineOrFocus);
    window.addEventListener("focus", onOnlineOrFocus);
    if (authOptions.enableBackgroundTokenRefresh) {
      client.getAuthenticationInfoOrNull();
      clientState.refreshInterval = window.setInterval(client.getAuthenticationInfoOrNull, 60000);
    }
  }
  return client;
}

const DEPRECATED_ORG_SELECTION_LOCAL_STORAGE_KEY = "__last_selected_org";

/**
 * @deprecated This hook is deprecated and no longer supported.
 */
function useActiveOrg() {
  const context = React.useContext(AuthContext);
  if (context === undefined) {
    throw new Error("useActiveOrg must be used within an AuthProvider or RequiredAuthProvider");
  }
  if (context.loading || !context.authInfo || !context.authInfo.orgHelper) {
    return null;
  }
  const proposedActiveOrgIdOrName = context.activeOrgFn();
  if (!proposedActiveOrgIdOrName) {
    return null;
  }
  const orgHelper = context.authInfo.orgHelper;
  return orgHelper.getOrg(proposedActiveOrgIdOrName) || orgHelper.getOrgByName(proposedActiveOrgIdOrName);
}
function saveOrgSelectionToLocalStorage(orgIdOrName) {
  if (localStorage) {
    localStorage.setItem(DEPRECATED_ORG_SELECTION_LOCAL_STORAGE_KEY, orgIdOrName);
  }
}
function loadOrgSelectionFromLocalStorage() {
  if (localStorage) {
    return localStorage.getItem(DEPRECATED_ORG_SELECTION_LOCAL_STORAGE_KEY);
  }
  return null;
}

const useClientRef = props => {
  const [accessTokenChangeCounter, setAccessTokenChangeCounter] = React.useState(0);
  const {
    authUrl
  } = props;

  // Use a ref to store the client so that it doesn't get recreated on every render
  const clientRef = React.useRef(null);
  if (clientRef.current === null) {
    const client = createClient({
      authUrl,
      enableBackgroundTokenRefresh: true
    });
    client.addAccessTokenChangeObserver(() => setAccessTokenChangeCounter(x => x + 1));
    clientRef.current = {
      authUrl,
      client
    };
  }

  // If the authUrl changes, destroy the old client and create a new one
  React.useEffect(() => {
    if (clientRef.current === null) {
      return;
    } else if (clientRef.current.authUrl === authUrl) {
      return;
    } else {
      clientRef.current.client.destroy();
      const newClient = createClient({
        authUrl,
        enableBackgroundTokenRefresh: true
      });
      newClient.addAccessTokenChangeObserver(() => setAccessTokenChangeCounter(x => x + 1));
      clientRef.current = {
        authUrl,
        client: newClient
      };
    }
  }, [authUrl]);
  return {
    clientRef,
    accessTokenChangeCounter
  };
};
const useClientRefCallback = (clientRef, callback) => {
  return React.useCallback((...inputs) => {
    const client = clientRef.current?.client;
    if (!client) {
      throw new Error("Client is not initialized");
    }
    return callback(client)(...inputs);
  }, [callback]);
};

const AuthContext = /*#__PURE__*/React__default["default"].createContext(undefined);
const initialAuthInfoState = {
  loading: true,
  authInfo: null
};
function authInfoStateReducer(_state, action) {
  if (!action.authInfo) {
    return {
      loading: false,
      authInfo: action.authInfo
    };
  } else if (_state.loading) {
    return {
      loading: false,
      authInfo: action.authInfo
    };
  } else if (_state.authInfo && _state.authInfo.accessToken !== action.authInfo.accessToken) {
    return {
      loading: false,
      authInfo: action.authInfo
    };
  } else {
    return _state;
  }
}
const AuthProvider = props => {
  const [authInfoState, dispatch] = React.useReducer(authInfoStateReducer, initialAuthInfoState);
  const {
    clientRef,
    accessTokenChangeCounter
  } = useClientRef({
    authUrl: props.authUrl
  });

  // Refresh the token when the user has logged in or out
  React.useEffect(() => {
    let didCancel = false;
    async function refreshToken() {
      const client = clientRef.current?.client;
      if (!client) {
        return;
      }
      try {
        const authInfo = await client.getAuthenticationInfoOrNull();
        if (!didCancel) {
          dispatch({
            authInfo
          });
        }
      } catch (_) {
        // Important errors are logged in the client library
      }
    }
    refreshToken();
    return () => {
      didCancel = true;
    };
  }, [accessTokenChangeCounter]);

  // Deprecation warning
  React.useEffect(() => {
    if (props.getActiveOrgFn) {
      console.warn("The `getActiveOrgFn` prop is deprecated.");
    }
  }, []);
  const logout = useClientRefCallback(clientRef, client => client.logout);
  const redirectToLoginPage = useClientRefCallback(clientRef, client => client.redirectToLoginPage);
  const redirectToSignupPage = useClientRefCallback(clientRef, client => client.redirectToSignupPage);
  const redirectToAccountPage = useClientRefCallback(clientRef, client => client.redirectToAccountPage);
  const redirectToOrgPage = useClientRefCallback(clientRef, client => client.redirectToOrgPage);
  const redirectToCreateOrgPage = useClientRefCallback(clientRef, client => client.redirectToCreateOrgPage);
  const redirectToSetupSAMLPage = useClientRefCallback(clientRef, client => client.redirectToSetupSAMLPage);
  const getLoginPageUrl = useClientRefCallback(clientRef, client => client.getLoginPageUrl);
  const getSignupPageUrl = useClientRefCallback(clientRef, client => client.getSignupPageUrl);
  const getAccountPageUrl = useClientRefCallback(clientRef, client => client.getAccountPageUrl);
  const getOrgPageUrl = useClientRefCallback(clientRef, client => client.getOrgPageUrl);
  const getCreateOrgPageUrl = useClientRefCallback(clientRef, client => client.getCreateOrgPageUrl);
  const getSetupSAMLPageUrl = useClientRefCallback(clientRef, client => client.getSetupSAMLPageUrl);
  const getAccessTokenForOrg = useClientRefCallback(clientRef, client => client.getAccessTokenForOrg);
  const refreshAuthInfo = React.useCallback(async () => {
    if (clientRef.current === null) {
      return;
    }
    const client = clientRef.current.client;
    const authInfo = await client.getAuthenticationInfoOrNull(true);
    dispatch({
      authInfo
    });
  }, [dispatch]);

  // TODO: Remove this, as both `getActiveOrgFn` and `loadOrgSelectionFromLocalStorage` are deprecated.
  const deprecatedActiveOrgFn = props.getActiveOrgFn || loadOrgSelectionFromLocalStorage;
  const {
    defaultDisplayWhileLoading,
    defaultDisplayIfLoggedOut
  } = props;
  const value = {
    loading: authInfoState.loading,
    authInfo: authInfoState.authInfo,
    logout,
    defaultDisplayWhileLoading,
    defaultDisplayIfLoggedOut,
    redirectToLoginPage,
    redirectToSignupPage,
    redirectToAccountPage,
    redirectToOrgPage,
    redirectToCreateOrgPage,
    redirectToSetupSAMLPage,
    getLoginPageUrl,
    activeOrgFn: deprecatedActiveOrgFn,
    getSignupPageUrl,
    getAccountPageUrl,
    getOrgPageUrl,
    getCreateOrgPageUrl,
    getSetupSAMLPageUrl,
    refreshAuthInfo,
    tokens: {
      getAccessTokenForOrg
    }
  };
  return /*#__PURE__*/React__default["default"].createElement(AuthContext.Provider, {
    value: value
  }, props.children);
};

// User information that we will hard code within the AuthProvider

/**
 * A version of the AuthProvider specifically used for testing. It won't make any external requests, but will
 * instead set up the AuthProvider to act as if the information provided was returned from the API.
 */
const AuthProviderForTesting = ({
  loading,
  userInformation,
  activeOrgFn,
  children
}) => {
  const authInfo = getAuthInfoForTesting(userInformation);
  const activeOrgFnWithDefault = activeOrgFn ? activeOrgFn : () => null;
  const contextValue = {
    loading: !!loading,
    authInfo,
    logout: () => Promise.resolve(),
    redirectToLoginPage: () => {},
    redirectToSignupPage: () => {},
    redirectToAccountPage: () => {},
    redirectToOrgPage: () => {},
    redirectToCreateOrgPage: () => {},
    redirectToSetupSAMLPage: () => {},
    getLoginPageUrl: () => "",
    getSignupPageUrl: () => "",
    getAccountPageUrl: () => "",
    getOrgPageUrl: () => "",
    getCreateOrgPageUrl: () => "",
    getSetupSAMLPageUrl: () => "",
    activeOrgFn: activeOrgFnWithDefault,
    refreshAuthInfo: () => Promise.resolve(),
    tokens: {
      getAccessTokenForOrg: () => Promise.resolve({
        error: undefined,
        accessToken: "ACCESS_TOKEN"
      })
    }
  };
  return /*#__PURE__*/React__default["default"].createElement(AuthContext.Provider, {
    value: contextValue
  }, children);
};
function getAuthInfoForTesting(userInformation) {
  if (!userInformation) {
    return null;
  }
  const orgIdToOrgMemberInfo = {};
  for (const orgMemberInfo of userInformation.orgMemberInfos) {
    orgIdToOrgMemberInfo[orgMemberInfo.orgId] = orgMemberInfo;
  }
  const accessTokenWithDefault = userInformation.accessToken === undefined ? "PLACEHOLDER_ACCESS_TOKEN" : userInformation.accessToken;
  return {
    accessToken: accessTokenWithDefault,
    expiresAtSeconds: 1701596820,
    orgHelper: getOrgHelper(orgIdToOrgMemberInfo),
    accessHelper: getAccessHelper(orgIdToOrgMemberInfo),
    orgIdToOrgMemberInfo: orgIdToOrgMemberInfo,
    user: userInformation.user,
    userClass: new UserClass(userInformation.user, toOrgIdToUserOrgInfo(orgIdToOrgMemberInfo))
  };
}
function toOrgIdToUserOrgInfo(orgIdToOrgMemberInfo) {
  const orgIdToUserOrgInfo = {};
  for (const orgMemberInfo of Object.values(orgIdToOrgMemberInfo)) {
    orgIdToUserOrgInfo[orgMemberInfo.orgId] = new OrgMemberInfoClass(orgMemberInfo.orgId, orgMemberInfo.orgName, {}, orgMemberInfo.urlSafeOrgName, orgMemberInfo.userAssignedRole, orgMemberInfo.userInheritedRolesPlusCurrentRole, orgMemberInfo.userPermissions);
  }
  return orgIdToUserOrgInfo;
}

// These helpers come from @propelauth/javascript, down the road we may want to export them from that library
//   instead of copying
function getOrgHelper(orgIdToOrgMemberInfo) {
  return {
    getOrg(orgId) {
      if (Object.prototype.hasOwnProperty.call(orgIdToOrgMemberInfo, orgId)) {
        return orgIdToOrgMemberInfo[orgId];
      } else {
        return undefined;
      }
    },
    getOrgIds() {
      return Object.keys(orgIdToOrgMemberInfo);
    },
    getOrgs() {
      return Object.values(orgIdToOrgMemberInfo);
    },
    getOrgByName(orgName) {
      for (const orgMemberInfo of Object.values(orgIdToOrgMemberInfo)) {
        if (orgMemberInfo.orgName === orgName || orgMemberInfo.urlSafeOrgName === orgName) {
          return orgMemberInfo;
        }
      }
      return undefined;
    }
  };
}
function getAccessHelper(orgIdToOrgMemberInfo) {
  function isRole(orgId, role) {
    const orgMemberInfo = orgIdToOrgMemberInfo[orgId];
    if (orgMemberInfo === undefined) {
      return false;
    }
    return orgMemberInfo.userAssignedRole === role;
  }
  function isAtLeastRole(orgId, role) {
    const orgMemberInfo = orgIdToOrgMemberInfo[orgId];
    if (orgMemberInfo === undefined) {
      return false;
    }
    return orgMemberInfo.userInheritedRolesPlusCurrentRole.includes(role);
  }
  function hasPermission(orgId, permission) {
    const orgMemberInfo = orgIdToOrgMemberInfo[orgId];
    if (orgMemberInfo === undefined) {
      return false;
    }
    return orgMemberInfo.userPermissions.includes(permission);
  }
  function hasAllPermissions(orgId, permissions) {
    const orgMemberInfo = orgIdToOrgMemberInfo[orgId];
    if (orgMemberInfo === undefined) {
      return false;
    }
    return permissions.every(permission => orgMemberInfo.userPermissions.includes(permission));
  }
  function getAccessHelperWithOrgId(orgId) {
    return {
      isRole(role) {
        return isRole(orgId, role);
      },
      isAtLeastRole(role) {
        return isAtLeastRole(orgId, role);
      },
      hasPermission(permission) {
        return hasPermission(orgId, permission);
      },
      hasAllPermissions(permissions) {
        return hasAllPermissions(orgId, permissions);
      }
    };
  }
  return {
    isRole,
    isAtLeastRole,
    hasPermission,
    hasAllPermissions,
    getAccessHelperWithOrgId
  };
}

function useAuthInfo() {
  const context = React.useContext(AuthContext);
  if (context === undefined) {
    throw new Error("useAuthInfo must be used within an AuthProvider or RequiredAuthProvider");
  }
  const {
    loading,
    authInfo,
    refreshAuthInfo,
    tokens
  } = context;
  if (loading) {
    return {
      loading: true,
      isLoggedIn: undefined,
      accessToken: undefined,
      orgHelper: undefined,
      accessHelper: undefined,
      user: undefined,
      userClass: undefined,
      isImpersonating: undefined,
      impersonatorUserId: undefined,
      refreshAuthInfo,
      tokens,
      accessTokenExpiresAtSeconds: undefined
    };
  } else if (authInfo && authInfo.accessToken) {
    return {
      loading: false,
      isLoggedIn: true,
      accessToken: authInfo.accessToken,
      orgHelper: authInfo.orgHelper,
      accessHelper: authInfo.accessHelper,
      user: authInfo.user,
      userClass: authInfo.userClass,
      isImpersonating: !!authInfo.impersonatorUserId,
      impersonatorUserId: authInfo.impersonatorUserId,
      refreshAuthInfo,
      tokens,
      accessTokenExpiresAtSeconds: authInfo.expiresAtSeconds
    };
  }
  return {
    loading: false,
    isLoggedIn: false,
    accessToken: null,
    user: null,
    userClass: null,
    orgHelper: null,
    accessHelper: null,
    isImpersonating: false,
    impersonatorUserId: undefined,
    refreshAuthInfo,
    tokens,
    accessTokenExpiresAtSeconds: undefined
  };
}

function useOrgHelper() {
  const authInfo = useAuthInfo();
  if (authInfo.loading) {
    return {
      loading: true,
      orgHelper: null
    };
  } else if (authInfo.isLoggedIn) {
    return {
      loading: false,
      orgHelper: authInfo.orgHelper
    };
  } else {
    return {
      loading: false,
      orgHelper: null
    };
  }
}
function useAccessHelper() {
  const authInfo = useAuthInfo();
  if (authInfo.loading) {
    return {
      loading: true,
      accessHelper: null
    };
  } else if (authInfo.isLoggedIn) {
    return {
      loading: false,
      accessHelper: authInfo.accessHelper
    };
  } else {
    return {
      loading: false,
      accessHelper: null
    };
  }
}

function useHostedPageUrls() {
  const context = React.useContext(AuthContext);
  if (context === undefined) {
    throw new Error("useHostedPageUrls must be used within an AuthProvider or RequiredAuthProvider");
  }
  const {
    getLoginPageUrl,
    getSignupPageUrl,
    getAccountPageUrl,
    getOrgPageUrl,
    getCreateOrgPageUrl,
    getSetupSAMLPageUrl
  } = context;
  return {
    getLoginPageUrl,
    getSignupPageUrl,
    getAccountPageUrl,
    getOrgPageUrl,
    getCreateOrgPageUrl,
    getSetupSAMLPageUrl
  };
}

function useLogoutFunction() {
  const context = React.useContext(AuthContext);
  if (context === undefined) {
    throw new Error("useLogoutFunction must be used within an AuthProvider or RequiredAuthProvider");
  }
  const {
    logout
  } = context;
  return logout;
}

function useRedirectFunctions() {
  const context = React.useContext(AuthContext);
  if (context === undefined) {
    throw new Error("useRedirectFunctions must be used within an AuthProvider or RequiredAuthProvider");
  }
  const {
    redirectToAccountPage,
    redirectToSignupPage,
    redirectToLoginPage,
    redirectToOrgPage,
    redirectToCreateOrgPage,
    redirectToSetupSAMLPage
  } = context;
  return {
    redirectToSignupPage,
    redirectToLoginPage,
    redirectToAccountPage,
    redirectToOrgPage,
    redirectToCreateOrgPage,
    redirectToSetupSAMLPage
  };
}
function RedirectToSignup({
  children,
  postSignupRedirectUrl,
  userSignupQueryParameters
}) {
  const {
    redirectToSignupPage
  } = useRedirectFunctions();
  React.useEffect(() => redirectToSignupPage({
    postSignupRedirectUrl,
    userSignupQueryParameters
  }), []);
  return /*#__PURE__*/React__default["default"].createElement(React__default["default"].Fragment, null, children);
}
function RedirectToLogin({
  children,
  postLoginRedirectUrl
}) {
  const {
    redirectToLoginPage
  } = useRedirectFunctions();
  React.useEffect(() => {
    if (postLoginRedirectUrl) {
      redirectToLoginPage({
        postLoginRedirectUrl
      });
    } else {
      redirectToLoginPage();
    }
  }, []);
  return /*#__PURE__*/React__default["default"].createElement(React__default["default"].Fragment, null, children);
}

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}

function createCommonjsModule(fn) {
  var module = { exports: {} };
	return fn(module, module.exports), module.exports;
}

/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var b="function"===typeof Symbol&&Symbol.for,c=b?Symbol.for("react.element"):60103,d=b?Symbol.for("react.portal"):60106,e=b?Symbol.for("react.fragment"):60107,f=b?Symbol.for("react.strict_mode"):60108,g=b?Symbol.for("react.profiler"):60114,h=b?Symbol.for("react.provider"):60109,k=b?Symbol.for("react.context"):60110,l=b?Symbol.for("react.async_mode"):60111,m=b?Symbol.for("react.concurrent_mode"):60111,n=b?Symbol.for("react.forward_ref"):60112,p=b?Symbol.for("react.suspense"):60113,q=b?
Symbol.for("react.suspense_list"):60120,r=b?Symbol.for("react.memo"):60115,t=b?Symbol.for("react.lazy"):60116,v=b?Symbol.for("react.block"):60121,w=b?Symbol.for("react.fundamental"):60117,x=b?Symbol.for("react.responder"):60118,y=b?Symbol.for("react.scope"):60119;
function z(a){if("object"===typeof a&&null!==a){var u=a.$$typeof;switch(u){case c:switch(a=a.type,a){case l:case m:case e:case g:case f:case p:return a;default:switch(a=a&&a.$$typeof,a){case k:case n:case t:case r:case h:return a;default:return u}}case d:return u}}}function A(a){return z(a)===m}var AsyncMode=l;var ConcurrentMode=m;var ContextConsumer=k;var ContextProvider=h;var Element=c;var ForwardRef=n;var Fragment=e;var Lazy=t;var Memo=r;var Portal=d;
var Profiler=g;var StrictMode=f;var Suspense=p;var isAsyncMode=function(a){return A(a)||z(a)===l};var isConcurrentMode=A;var isContextConsumer=function(a){return z(a)===k};var isContextProvider=function(a){return z(a)===h};var isElement=function(a){return "object"===typeof a&&null!==a&&a.$$typeof===c};var isForwardRef=function(a){return z(a)===n};var isFragment=function(a){return z(a)===e};var isLazy=function(a){return z(a)===t};
var isMemo=function(a){return z(a)===r};var isPortal=function(a){return z(a)===d};var isProfiler=function(a){return z(a)===g};var isStrictMode=function(a){return z(a)===f};var isSuspense=function(a){return z(a)===p};
var isValidElementType=function(a){return "string"===typeof a||"function"===typeof a||a===e||a===m||a===g||a===f||a===p||a===q||"object"===typeof a&&null!==a&&(a.$$typeof===t||a.$$typeof===r||a.$$typeof===h||a.$$typeof===k||a.$$typeof===n||a.$$typeof===w||a.$$typeof===x||a.$$typeof===y||a.$$typeof===v)};var typeOf=z;

var reactIs_production_min = {
	AsyncMode: AsyncMode,
	ConcurrentMode: ConcurrentMode,
	ContextConsumer: ContextConsumer,
	ContextProvider: ContextProvider,
	Element: Element,
	ForwardRef: ForwardRef,
	Fragment: Fragment,
	Lazy: Lazy,
	Memo: Memo,
	Portal: Portal,
	Profiler: Profiler,
	StrictMode: StrictMode,
	Suspense: Suspense,
	isAsyncMode: isAsyncMode,
	isConcurrentMode: isConcurrentMode,
	isContextConsumer: isContextConsumer,
	isContextProvider: isContextProvider,
	isElement: isElement,
	isForwardRef: isForwardRef,
	isFragment: isFragment,
	isLazy: isLazy,
	isMemo: isMemo,
	isPortal: isPortal,
	isProfiler: isProfiler,
	isStrictMode: isStrictMode,
	isSuspense: isSuspense,
	isValidElementType: isValidElementType,
	typeOf: typeOf
};

/** @license React v16.13.1
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var reactIs_development = createCommonjsModule(function (module, exports) {



if (process.env.NODE_ENV !== "production") {
  (function() {

// The Symbol used to tag the ReactElement-like types. If there is no native Symbol
// nor polyfill, then a plain number is used for performance.
var hasSymbol = typeof Symbol === 'function' && Symbol.for;
var REACT_ELEMENT_TYPE = hasSymbol ? Symbol.for('react.element') : 0xeac7;
var REACT_PORTAL_TYPE = hasSymbol ? Symbol.for('react.portal') : 0xeaca;
var REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for('react.fragment') : 0xeacb;
var REACT_STRICT_MODE_TYPE = hasSymbol ? Symbol.for('react.strict_mode') : 0xeacc;
var REACT_PROFILER_TYPE = hasSymbol ? Symbol.for('react.profiler') : 0xead2;
var REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for('react.provider') : 0xeacd;
var REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for('react.context') : 0xeace; // TODO: We don't use AsyncMode or ConcurrentMode anymore. They were temporary
// (unstable) APIs that have been removed. Can we remove the symbols?

var REACT_ASYNC_MODE_TYPE = hasSymbol ? Symbol.for('react.async_mode') : 0xeacf;
var REACT_CONCURRENT_MODE_TYPE = hasSymbol ? Symbol.for('react.concurrent_mode') : 0xeacf;
var REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.for('react.forward_ref') : 0xead0;
var REACT_SUSPENSE_TYPE = hasSymbol ? Symbol.for('react.suspense') : 0xead1;
var REACT_SUSPENSE_LIST_TYPE = hasSymbol ? Symbol.for('react.suspense_list') : 0xead8;
var REACT_MEMO_TYPE = hasSymbol ? Symbol.for('react.memo') : 0xead3;
var REACT_LAZY_TYPE = hasSymbol ? Symbol.for('react.lazy') : 0xead4;
var REACT_BLOCK_TYPE = hasSymbol ? Symbol.for('react.block') : 0xead9;
var REACT_FUNDAMENTAL_TYPE = hasSymbol ? Symbol.for('react.fundamental') : 0xead5;
var REACT_RESPONDER_TYPE = hasSymbol ? Symbol.for('react.responder') : 0xead6;
var REACT_SCOPE_TYPE = hasSymbol ? Symbol.for('react.scope') : 0xead7;

function isValidElementType(type) {
  return typeof type === 'string' || typeof type === 'function' || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
  type === REACT_FRAGMENT_TYPE || type === REACT_CONCURRENT_MODE_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || typeof type === 'object' && type !== null && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_RESPONDER_TYPE || type.$$typeof === REACT_SCOPE_TYPE || type.$$typeof === REACT_BLOCK_TYPE);
}

function typeOf(object) {
  if (typeof object === 'object' && object !== null) {
    var $$typeof = object.$$typeof;

    switch ($$typeof) {
      case REACT_ELEMENT_TYPE:
        var type = object.type;

        switch (type) {
          case REACT_ASYNC_MODE_TYPE:
          case REACT_CONCURRENT_MODE_TYPE:
          case REACT_FRAGMENT_TYPE:
          case REACT_PROFILER_TYPE:
          case REACT_STRICT_MODE_TYPE:
          case REACT_SUSPENSE_TYPE:
            return type;

          default:
            var $$typeofType = type && type.$$typeof;

            switch ($$typeofType) {
              case REACT_CONTEXT_TYPE:
              case REACT_FORWARD_REF_TYPE:
              case REACT_LAZY_TYPE:
              case REACT_MEMO_TYPE:
              case REACT_PROVIDER_TYPE:
                return $$typeofType;

              default:
                return $$typeof;
            }

        }

      case REACT_PORTAL_TYPE:
        return $$typeof;
    }
  }

  return undefined;
} // AsyncMode is deprecated along with isAsyncMode

var AsyncMode = REACT_ASYNC_MODE_TYPE;
var ConcurrentMode = REACT_CONCURRENT_MODE_TYPE;
var ContextConsumer = REACT_CONTEXT_TYPE;
var ContextProvider = REACT_PROVIDER_TYPE;
var Element = REACT_ELEMENT_TYPE;
var ForwardRef = REACT_FORWARD_REF_TYPE;
var Fragment = REACT_FRAGMENT_TYPE;
var Lazy = REACT_LAZY_TYPE;
var Memo = REACT_MEMO_TYPE;
var Portal = REACT_PORTAL_TYPE;
var Profiler = REACT_PROFILER_TYPE;
var StrictMode = REACT_STRICT_MODE_TYPE;
var Suspense = REACT_SUSPENSE_TYPE;
var hasWarnedAboutDeprecatedIsAsyncMode = false; // AsyncMode should be deprecated

function isAsyncMode(object) {
  {
    if (!hasWarnedAboutDeprecatedIsAsyncMode) {
      hasWarnedAboutDeprecatedIsAsyncMode = true; // Using console['warn'] to evade Babel and ESLint

      console['warn']('The ReactIs.isAsyncMode() alias has been deprecated, ' + 'and will be removed in React 17+. Update your code to use ' + 'ReactIs.isConcurrentMode() instead. It has the exact same API.');
    }
  }

  return isConcurrentMode(object) || typeOf(object) === REACT_ASYNC_MODE_TYPE;
}
function isConcurrentMode(object) {
  return typeOf(object) === REACT_CONCURRENT_MODE_TYPE;
}
function isContextConsumer(object) {
  return typeOf(object) === REACT_CONTEXT_TYPE;
}
function isContextProvider(object) {
  return typeOf(object) === REACT_PROVIDER_TYPE;
}
function isElement(object) {
  return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
}
function isForwardRef(object) {
  return typeOf(object) === REACT_FORWARD_REF_TYPE;
}
function isFragment(object) {
  return typeOf(object) === REACT_FRAGMENT_TYPE;
}
function isLazy(object) {
  return typeOf(object) === REACT_LAZY_TYPE;
}
function isMemo(object) {
  return typeOf(object) === REACT_MEMO_TYPE;
}
function isPortal(object) {
  return typeOf(object) === REACT_PORTAL_TYPE;
}
function isProfiler(object) {
  return typeOf(object) === REACT_PROFILER_TYPE;
}
function isStrictMode(object) {
  return typeOf(object) === REACT_STRICT_MODE_TYPE;
}
function isSuspense(object) {
  return typeOf(object) === REACT_SUSPENSE_TYPE;
}

exports.AsyncMode = AsyncMode;
exports.ConcurrentMode = ConcurrentMode;
exports.ContextConsumer = ContextConsumer;
exports.ContextProvider = ContextProvider;
exports.Element = Element;
exports.ForwardRef = ForwardRef;
exports.Fragment = Fragment;
exports.Lazy = Lazy;
exports.Memo = Memo;
exports.Portal = Portal;
exports.Profiler = Profiler;
exports.StrictMode = StrictMode;
exports.Suspense = Suspense;
exports.isAsyncMode = isAsyncMode;
exports.isConcurrentMode = isConcurrentMode;
exports.isContextConsumer = isContextConsumer;
exports.isContextProvider = isContextProvider;
exports.isElement = isElement;
exports.isForwardRef = isForwardRef;
exports.isFragment = isFragment;
exports.isLazy = isLazy;
exports.isMemo = isMemo;
exports.isPortal = isPortal;
exports.isProfiler = isProfiler;
exports.isStrictMode = isStrictMode;
exports.isSuspense = isSuspense;
exports.isValidElementType = isValidElementType;
exports.typeOf = typeOf;
  })();
}
});

var reactIs = createCommonjsModule(function (module) {

if (process.env.NODE_ENV === 'production') {
  module.exports = reactIs_production_min;
} else {
  module.exports = reactIs_development;
}
});

/**
 * Copyright 2015, Yahoo! Inc.
 * Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.
 */
var REACT_STATICS = {
  childContextTypes: true,
  contextType: true,
  contextTypes: true,
  defaultProps: true,
  displayName: true,
  getDefaultProps: true,
  getDerivedStateFromError: true,
  getDerivedStateFromProps: true,
  mixins: true,
  propTypes: true,
  type: true
};
var KNOWN_STATICS = {
  name: true,
  length: true,
  prototype: true,
  caller: true,
  callee: true,
  arguments: true,
  arity: true
};
var FORWARD_REF_STATICS = {
  '$$typeof': true,
  render: true,
  defaultProps: true,
  displayName: true,
  propTypes: true
};
var MEMO_STATICS = {
  '$$typeof': true,
  compare: true,
  defaultProps: true,
  displayName: true,
  propTypes: true,
  type: true
};
var TYPE_STATICS = {};
TYPE_STATICS[reactIs.ForwardRef] = FORWARD_REF_STATICS;
TYPE_STATICS[reactIs.Memo] = MEMO_STATICS;

function getStatics(component) {
  // React v16.11 and below
  if (reactIs.isMemo(component)) {
    return MEMO_STATICS;
  } // React v16.12 and above


  return TYPE_STATICS[component['$$typeof']] || REACT_STATICS;
}

var defineProperty = Object.defineProperty;
var getOwnPropertyNames = Object.getOwnPropertyNames;
var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
var getPrototypeOf = Object.getPrototypeOf;
var objectPrototype = Object.prototype;
function hoistNonReactStatics(targetComponent, sourceComponent, blacklist) {
  if (typeof sourceComponent !== 'string') {
    // don't hoist over string (html) components
    if (objectPrototype) {
      var inheritedComponent = getPrototypeOf(sourceComponent);

      if (inheritedComponent && inheritedComponent !== objectPrototype) {
        hoistNonReactStatics(targetComponent, inheritedComponent, blacklist);
      }
    }

    var keys = getOwnPropertyNames(sourceComponent);

    if (getOwnPropertySymbols) {
      keys = keys.concat(getOwnPropertySymbols(sourceComponent));
    }

    var targetStatics = getStatics(targetComponent);
    var sourceStatics = getStatics(sourceComponent);

    for (var i = 0; i < keys.length; ++i) {
      var key = keys[i];

      if (!KNOWN_STATICS[key] && !(blacklist && blacklist[key]) && !(sourceStatics && sourceStatics[key]) && !(targetStatics && targetStatics[key])) {
        var descriptor = getOwnPropertyDescriptor(sourceComponent, key);

        try {
          // Avoid failures from read-only properties
          defineProperty(targetComponent, key, descriptor);
        } catch (e) {}
      }
    }
  }

  return targetComponent;
}

var hoistNonReactStatics_cjs = hoistNonReactStatics;

function withRequiredAuthInfo(Component, args) {
  const displayName = `withRequiredAuthInfo(${Component.displayName || Component.name || "Component"})`;
  const WithRequiredAuthInfoWrapper = props => {
    const context = React.useContext(AuthContext);
    if (context === undefined) {
      throw new Error("withRequiredAuthInfo must be used within an AuthProvider or RequiredAuthProvider");
    }
    const {
      loading,
      authInfo,
      defaultDisplayIfLoggedOut,
      defaultDisplayWhileLoading,
      refreshAuthInfo,
      tokens
    } = context;
    function displayLoading() {
      if (args?.displayWhileLoading) {
        return args.displayWhileLoading;
      } else if (defaultDisplayWhileLoading) {
        return defaultDisplayWhileLoading;
      }
      return /*#__PURE__*/React__default["default"].createElement(React__default["default"].Fragment, null);
    }
    function displayLoggedOut() {
      if (args?.displayIfLoggedOut) {
        return args.displayIfLoggedOut;
      } else if (defaultDisplayIfLoggedOut) {
        return defaultDisplayIfLoggedOut;
      }
      return /*#__PURE__*/React__default["default"].createElement(RedirectToLogin, null);
    }
    if (loading) {
      return displayLoading();
    } else if (authInfo) {
      const loggedInProps = {
        ...props,
        accessToken: authInfo.accessToken,
        isLoggedIn: !!authInfo.accessToken,
        orgHelper: authInfo.orgHelper,
        accessHelper: authInfo.accessHelper,
        user: authInfo.user,
        userClass: authInfo.userClass,
        isImpersonating: !!authInfo.impersonatorUserId,
        impersonatorUserId: authInfo.impersonatorUserId,
        refreshAuthInfo,
        tokens,
        accessTokenExpiresAtSeconds: authInfo.expiresAtSeconds
      };
      return /*#__PURE__*/React__default["default"].createElement(Component, loggedInProps);
    } else {
      return displayLoggedOut();
    }
  };
  WithRequiredAuthInfoWrapper.displayName = displayName;
  WithRequiredAuthInfoWrapper.WrappedComponent = Component;
  return hoistNonReactStatics_cjs(WithRequiredAuthInfoWrapper, Component);
}

const RequiredAuthWrappedComponent = withRequiredAuthInfo(({
  children
}) => /*#__PURE__*/React__default["default"].createElement(React__default["default"].Fragment, null, children));
const RequiredAuthProvider = props => {
  const {
    children,
    displayIfLoggedOut,
    displayWhileLoading,
    ...sharedProps
  } = props;
  return /*#__PURE__*/React__default["default"].createElement(AuthProvider, _extends({}, sharedProps, {
    defaultDisplayIfLoggedOut: displayIfLoggedOut,
    defaultDisplayWhileLoading: displayWhileLoading
  }), /*#__PURE__*/React__default["default"].createElement(RequiredAuthWrappedComponent, null, children));
};

function withAuthInfo(Component, args) {
  const displayName = `withAuthInfo(${Component.displayName || Component.name || "Component"})`;
  const WithAuthInfoWrapper = props => {
    const context = React.useContext(AuthContext);
    if (context === undefined) {
      throw new Error("withAuthInfo must be used within an AuthProvider or RequiredAuthProvider");
    }
    const {
      loading,
      authInfo,
      defaultDisplayWhileLoading,
      refreshAuthInfo,
      tokens
    } = context;
    function displayLoading() {
      if (args?.displayWhileLoading) {
        return args.displayWhileLoading;
      } else if (defaultDisplayWhileLoading) {
        return defaultDisplayWhileLoading;
      }
      return /*#__PURE__*/React__default["default"].createElement(React__default["default"].Fragment, null);
    }
    if (loading) {
      return displayLoading();
    } else if (authInfo) {
      const loggedInProps = {
        ...props,
        accessToken: authInfo.accessToken,
        isLoggedIn: !!authInfo.accessToken,
        orgHelper: authInfo.orgHelper,
        accessHelper: authInfo.accessHelper,
        user: authInfo.user,
        userClass: authInfo.userClass,
        isImpersonating: !!authInfo.impersonatorUserId,
        impersonatorUserId: authInfo.impersonatorUserId,
        refreshAuthInfo,
        tokens,
        accessTokenExpiresAtSeconds: authInfo.expiresAtSeconds
      };
      return /*#__PURE__*/React__default["default"].createElement(Component, loggedInProps);
    } else {
      const notLoggedInProps = {
        ...props,
        accessToken: null,
        isLoggedIn: false,
        user: null,
        userClass: null,
        orgHelper: null,
        accessHelper: null,
        isImpersonating: false,
        impersonatorUserId: null,
        refreshAuthInfo,
        tokens,
        accessTokenExpiresAtSeconds: null
      };
      return /*#__PURE__*/React__default["default"].createElement(Component, notLoggedInProps);
    }
  };
  WithAuthInfoWrapper.displayName = displayName;
  WithAuthInfoWrapper.WrappedComponent = Component;
  return hoistNonReactStatics_cjs(WithAuthInfoWrapper, Component);
}

exports.AuthProvider = AuthProvider;
exports.AuthProviderForTesting = AuthProviderForTesting;
exports.OrgMemberInfoClass = OrgMemberInfoClass;
exports.RedirectToLogin = RedirectToLogin;
exports.RedirectToSignup = RedirectToSignup;
exports.RequiredAuthProvider = RequiredAuthProvider;
exports.UserClass = UserClass;
exports.loadOrgSelectionFromLocalStorage = loadOrgSelectionFromLocalStorage;
exports.saveOrgSelectionToLocalStorage = saveOrgSelectionToLocalStorage;
exports.useAccessHelper = useAccessHelper;
exports.useActiveOrg = useActiveOrg;
exports.useAuthInfo = useAuthInfo;
exports.useHostedPageUrls = useHostedPageUrls;
exports.useLogoutFunction = useLogoutFunction;
exports.useOrgHelper = useOrgHelper;
exports.useRedirectFunctions = useRedirectFunctions;
exports.withAuthInfo = withAuthInfo;
exports.withRequiredAuthInfo = withRequiredAuthInfo;
//# sourceMappingURL=index.cjs.js.map
